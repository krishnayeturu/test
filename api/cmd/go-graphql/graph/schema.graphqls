# GraphQL schema example
#
# https://gqlgen.com/getting-started/
enum Effect {
  ALLOW
  DENY
}

enum AdmissionPolicyType {
  CREDENTIAL
}

type AdmissionPolicy {
  id: ID!
  name: String!
  effect: Effect
  type: AdmissionPolicyType
  principal: [String]! # list of PARNs representing various principals - parn:user:::myusername, credential.prod-eng.2nd.watch, etc
  actions: [String]! # credential:Read, credential:Write, admissionPolicy:Read, etc
  resources: [String]! # identifier for what you have access to records-wise -- allow for wildcard - parn:credential:::my-credential-name, parn:user:::some-user-name, etc
}

type AdmissionPrincipalEvalutation { # input model for evaluating if principal has action on resource
  # id: ID!
  # policyId: String!
  # effect: Effect
  ttl: String
  principal: String! # list of PARNs representing various principals - parn:user:::myusername, credential.prod-eng.2nd.watch, etc
  action: String # credential:Read, credential:Write, admissionPolicy:Read, etc
  resource: String # identifier for what you have access to records-wise -- allow for wildcard - parn:credential:::my-credential-name, parn:user:::some-user-name, etc
}

type AdmissionPrincipalAuthorization { # output model for evaluating if principal has action on resource
  principal: String!
  authorizationResult: Boolean!
  expireTime: String
}

type AdmissionPrincipalView { # model for reading records for an admission principal
  id: ID
  policyId: String!
  effect: Effect!
  principal: String! # list of PARNs representing various principals - parn:user:::myusername, credential.prod-eng.2nd.watch, etc
  action: String # credential:Read, credential:Write, admissionPolicy:Read, etc
  resource: String # identifier for what you have access to records-wise -- allow for wildcard - parn:credential:::my-credential-name, parn:user:::some-user-name, etc
}

input AdmissionPolicyInput {
  id: String
  name: String!
  effect: Effect
  type: AdmissionPolicyType
  principal: [String]! # list of PARNs representing various principals - parn:user:::myusername, credential.prod-eng.2nd.watch, etc
  actions: [String]! # credential:Read, credential:Write, admissionPolicy:Read, etc
  resources: [String]! # identifier for what you have access to records-wise -- allow for wildcard - parn:credential:::my-credential-name, parn:user:::some-user-name, etc
}

type Query {
  admissionPolicies(principal: String!, policyType: AdmissionPolicyType, policyName: String): [AdmissionPolicy]!
  todos: [Todo!]!
}

type Mutation {
  createAdmissionPolicy(admissionPolicy: AdmissionPolicyInput!): AdmissionPolicy
  updateAdmissionPolicyActions(id: String!, admissionPolicyActions: [String]): AdmissionPolicy # encompasses add, update, delete
  updateAdmissionPolicyPrincipals(id: String!, admissionPolicyPrincipals: [String]): AdmissionPolicy # encompasses add, update, delete
  updateAdmissionPolicyResources(id: String!, admissionPolicyResources: [String]): AdmissionPolicy # encompasses add, update, delete
  deleteAdmissionPolicy(id: String!): Boolean
  createTodo(input: NewTodo!): Todo!
}

# original generated model schema below
type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type User {
  id: ID!
  name: String!
}

input NewTodo {
  text: String!
  userId: String!
}